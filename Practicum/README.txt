Идея алгоритма состоит в том, чтобы переопределить операции при парсинге
регулярного выражения в обратной польской нотации. Для этого нам понадобится
на стеке парсинга хранить вершины, которые содержат:
    prefix[i] - наименьшая длина слова x^iv из языка.
    word[i] - наименьшая длина x^t из языка, t >= i.

При реализации возникло много трудностей связанных с выходом за пределы слова,
длинной больше k. Все они описаны в комментариях в коде алгоритма. Кратко о том,
как определить операции для парсинга:

. - Существует 4 случая при конкатенации, u, v - не пусто:
      x^n.x^m
      x^n u + x^m v
      x^n u + x^m
      x^n + x^m v

* - Строим орбиту для каждого слова, слово существует, если prefix[i] не INF.
    Необходимо помнить про выход за пределы k.

+ - Поокоординатный минимум.

Recovery() - необходим для восстановления свойств prefix[] и word[],
во время работы алгоритма, вычисляются только "настоящие" слова,
такие, которые были бы созданы регулярными выражениями,
но и prefix[i] и word[i] по своим свойствам невсегда настоящие,
например, word[i] != i, значит, что слово, если оно существует,
имеет длину i, но оно больше, чем word[i],
тоже из-за того, что есть выходы за пределы k.

На каждый символ не более k^2 итерации => асимптотика O(k^2 * |expression|).