Практикум №1

Регулярные выражения:

В каждой задаче нужно реализовать на языке C++, Python или Haskell некоторый алгоритм обработки регулярных выражений. В каждой задаче аргументами
являются строка в алфавите {a, b, c, 1, ., +, ∗}, а также некоторые дополнительные
параметры. Если задача предполагает ответ «да/нет», то необходимо вывести yes в
случае положительного ответа и no — в случае отрицательного. В случае, если ответ
является целым числом или словом, необходимо вывести это число или слово. В случае, если таких числа или слова не существует, необходимо вывести INF. В случае,
если входная строка не является корректным регулярным выражением в обратной
польской записи, необходимо выдать сообщение error об ошибке. Дополнительные
случаи оговорены непосредственно при формулировке задачи.
В дальнейшем предполагается, что первым компонентом входа является регулярное
выражение α в обратной польской записи, задающее язык L.

Даны α, буква x и натуральное число k. Вывести длину кратчайшего слова из
языка L, содержащего префикс x^k


Идея алгоритма состоит в том, чтобы переопределить операции при парсинге
регулярного выражения в обратной польской нотации. Для этого нам понадобится
на стеке парсинга хранить вершины, которые содержат:
    prefix[i] - наименьшая длина слова x^iv из языка.

При реализации возникло много трудностей связанных с выходом за пределы слова,
длинной больше k. Все они описаны в комментариях в коде алгоритма. Кратко о том,
как определить операции для парсинга:

concat. - Существует 4 случая при конкатенации, при реализации объедены в 2 случая:

	x^n.x^m
	x^n u + x^m v
	x^n u + x^m
	x^n + x^m v

star* - всевозможные префикс-слова из префикс-слов,
	восстановить массив ответов,
	а потом прибавить к получившимся префикс-словам всевозможные слова,
	что займёт O(k^3)

or+ - Поокоординатный минимум.

Recovery() - необходим для восстановления свойств prefix[],
во время работы алгоритма, вычисляются только "настоящие" слова,
такие, которые были бы созданы регулярными выражениями,
например, prefix[i] != i, значит, что слово, если оно существует,
имеет длину prefix[i], но сама длина больше, чем длина префикса i.

На каждый символ не более k^3 итерации => асимптотика O(k^3 * |expression|).

Внимание! Не забывать о том, что:
	Прежде, чем изменять массив нужно убедиться, что всё существует IsWordExist()
	Не забывать Recovery()
