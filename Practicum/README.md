Идея алгоритма состоит в том, чтобы переопределить операции при парсинге
регулярного выражения в обратной польской нотации. Для этого нам понадобится
на стеке парсинга хранить вершины, которые содержат:
    prefix[i] - наименьшая длина слова x^iv из языка.

При реализации возникло много трудностей связанных с выходом за пределы слова,
длинной больше k. Все они описаны в комментариях в коде алгоритма. Кратко о том,
как определить операции для парсинга:

concat. - Существует 4 случая при конкатенации, при реализации объедены в 2 случая:
      x^n.x^m
      x^n u + x^m v
      x^n u + x^m
      x^n + x^m v

star* - всевозможные префикс-слова из префикс-слов,
	восстановить массив ответов,
	а потом прибавить к получившимся префикс-словам всевозможные слова,
	что займёт O(k^3)

or+ - Поокоординатный минимум.

Recovery() - необходим для восстановления свойств prefix[],
во время работы алгоритма, вычисляются только "настоящие" слова,
такие, которые были бы созданы регулярными выражениями,
например, prefix[i] != i, значит, что слово, если оно существует,
имеет длину prefix[i], но сама длина больше, чем длина префикса i.

На каждый символ не более k^3 итерации => асимптотика O(k^3 * |expression|).

Внимание! Не забывать о том, что:
	Прежде, чем изменять массив нужно убедиться, что всё существует IsWordExist()
	Не забывать Recovery()
